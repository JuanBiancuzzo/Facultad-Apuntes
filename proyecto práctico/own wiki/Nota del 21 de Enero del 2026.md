---
dia: 2026-01-21
tags:
  - proyecto-práctico/Own-wiki
  - nota/proyecto
---
# Progreso
---
De nuevo con cambios a la estructura general del proyecto. Actualmente definimos la estructura del proyecto como dos [[ingeniería en informática/sisop/La abstracción de proceso/Proceso|procesos]], uno corresponde al sistema, donde se tiene la [[ingeniería en informática/bdd/General/Base de datos|base de datos]] de la [[Aplicación|aplicación]] y se carga la base de datos del proyecto en ejecución; en el otro proceso se tiene el usuario, asistido por un cliente (código escrito por mi), donde este puede ejecutar las views sin tener el miedo de crashear todo el programa

La comunicación entre los procesos se hace por medio de [[investigación/networking/Remote Procedure Call#gRPC|gRPC]] para poder abstraernos del lenguaje que está por debajo. El proceso del sistema actualmente se encuentra escrito en [[investigación/ciencias de la computación/lenguajes de programación/lenguaje go/Lenguaje go|Golang]] pero tengo la intención que después de poder hacer un prototipo funcional, este pase a estar escrito en [[investigación/ciencias de la computación/lenguajes de programación/lenguaje zig/Lenguaje Zig|Zig]]. El proceso del usuario va a estar escrito en Golang y espero mantenerlo así ya que me parece un muy buen lenguaje para un usuario promedio que quiera usar la aplicación

## gRPC
---
Actualmente vamos a usar gRPC para hacer de intermediario entre el código generado por el usuario y la aplicación. Por su funcionamiento se tiene que definir un [[Protocol Buffer|protocol buffer]] el cual definimos como 

```protobuf
service UserInteraction {
    // Loads the user code given by a path, and register the component structures
    //  to save the data
    rpc LoadPlugin(LoadPluginRequest) returns (LoadPluginResponse);

    // Lets the user load data from files and returns the component data
    rpc ImportFiles(stream ImportedFilesRequest) returns (stream ImportFilesResponse);

    // Lets the user render the data, and changes its behaviour given the events 
    //  of the system
    rpc Render(stream RenderRequest) returns (stream RenderResponse);
}

service SystemInteraction {
    // Lets the system send the data to the user, that was save
    rpc Query(QueryRequest) returns (QueryResponse);

    // Lets the system receive events that are generated by the user
    rpc SendEvent(SendEventRequest) returns (Empty);
}
```

Donde tenemos dos servicios. El servicio de `UserInteraction` define las funciones que el proceso representado por el usuario, debe cumplir
* Buscar los archivos del usuario y devolver los componentes que definió el usuario
* Una función de procesamiento de archivos para realizar inserciones a la base de datos
* La función de renderización la cual permite recibir información del frame y eventos de ese frame, y devuelve la construcción de la escena para mostrarse

Por otro lado, el servicio de `SystemInteraction` define las funciones que el proceso representado por la aplicación y debe cumplir
* Responder a [[ingeniería en informática/bdd/SQL/Sentencia de SQL|querys]] de la base de datos y devolver la información pedida
* Recibir eventos generados por el usuario

## Views
---
Tenemos el problema que las animaciones se prestan mucho más al [[Retain mode|retain mode]], mientras que las [[ingeniería en informática/aninfo/Prototipado y experiencia del usuario/Interfaz de usuario|UI]] se prestan mucho más al [[Immediate mode|immediate mode]].  


```go
type FnYield func() <-chan []Event

type View interface {
	View(scene *Scene, yield FnYield) View
}
```

Esta interfaz representa más el retain mode, pero tal vez hay que ver si se debería usar immediate mode

Por otro lado, para resolver el problema de inyectar funcionalidad a la interfaz de view, y la diferenciación entre views que usan el sistema y view que no. La solución viene por la realización que se tiene el código del usuario en texto plano, por lo que no necesariamente necesitamos plantear una solución que implique primero compilarlo y después usarlo, sino que podemos modificar el código del usuario 

Por lo tanto, la solución consiste en agarrar el código del usuario, identificar los componentes, las entidades y las views, para poder generar código extra en su utilización. Es decir, si se tiene el siguiente código

```go
//@component 
type BookComponent struct {
    Name   string
    Author string
    Year   int
}

//@component
type ChapterComponent struct {
    Book   *BookComponent
    Name   Optional[string]
    Number int
}

//@entity
type BookEntity struct {
    Book     BookChapter
    Chapters []ChapterComponent
}

//@entity
type LibraryEntity struct {
    Books []BookEntity
}

//@view
type MainView struct {
    Library LibraryEntity
}

func (mv *MainView) View(scene *Scene, yield FnYield) View {
    for _, bookEntity := range mv.Library.Books {
        book := bookEntity.Book
        scene.Add(
            Text("%s of %s", book.Name, book.Author),
        )
    }

    return nil
}
```

Entonces por los comentarios se puede ver cuales son los componentes, las entidades y las views. Después algo importante a notar es que en la main view, a pesar de requerir los libros con sus correspondientes capítulos, solo se usa los [[ingeniería en informática/bdd/General/Campo|campos]] "Name" y "Author", por lo que necesitamos generar una query que tenga todos los libros pero que solo pida por el nombre y el autor, y no hacer el [[ingeniería en informática/orga/Pandas/Merge|join]] con los capítulos

Por otro lado si se asignara un valor al campo de un libro, se puede entonces generar la [[ingeniería en informática/bdd/SQL/Sentencia de SQL|sentencia]] para escribir información a la base de datos, generando así un uso eficiente y especifico a cada view

La forma de poder hacer todo este procesamiento es por medio de [[Tree-sitter Grammar|tree-sitter]], como motor de queries del [[Abstract Syntax Tree (AST)|AST]]. Usando también `go/type` para hacer la relación entre `book.Name` a el componente de `BookComponent`

### Retain mode vs. Immediate mode
---
Ejemplifiquemos ambas posibilidades, para poder entender mejor cual conviene para nuestro proyecto

Como ejemplo de retain mode, inspirado en Manim donde se crean MObjects y se agregan a la escena. También devolver una view implica que view se renderiza después, y en el caso de no devolver nada representa que se terminó de renderizar

```go
type OtherView struct {
    // ...
}

func InitOtherView() *OtherView {
	return &OtherView{ /* ... */ }
}

type ExampleView struct {
    cube *v.Cube
}

func InitExampleView() *ExampleView {
	return &ExampleView{ cube: v.NewCube({ X: 0, Y: 0, H: 1, W: 2 }) }
}

func (ev *ExampleView) View(scene *s.Scene, yield v.FnYield) v.View {
    bottonChange := v.NewButton({ 
        Text: "Change to other", X: 2, Y: 2, H: 1, W: 2, 
    })
    bottonReset := v.NewButton({ 
        Text: "Reset", X: 4, Y: 2, H: 1, W: 2 
    })
    
    scene.Add(ev.cube, bottonChange, buttonReset)
    
    // preload the init of the other view as if it was heavy computationally
    channelOtherView := make(chan v.View)
    go func() {
        channelOtherView <- InitOtherView()
    }()
    
    i := 0
    for range yield() {
        ev.cube.X = i
        ev.cube.Y = 2 * i
    
        if buttonChange.Check() {
            return <- channelOtherView
            
        } else if buttonReset.Check() {
            return InitExampleView()
        }
        
        i++
    }
    return nil
}
```

Como ejemplo de immediate mode, inspirado en [[P5Js|p5js]] donde se modifica la interfaz de la view se modifica y se llama completamente para definir la escena. Se devuelve que view se va a mostrar en el frame siguiente por lo que si se quiere pasar información de un frame al otro se devuelve la misma view

```go
type OtherView struct {
    // ...
}

func InitOtherView() *OtherView {
	return &OtherView{ /* ... */ }
}

type ExampleView struct {
	i int
}

func InitExampleView() *ExampleView {
	return &ExampleView{ i: 0 }
}

func (ev *ExampleView) View(scene *s.Scene) View {
	// pass the configuration as a struct
	scene.AddCube({ X: ev.i, Y: 2 * ev.i, H: 1, W: 2 }) 

	// Change behaviour
	if scene.AddBotton("Change to other", { X: 2, Y: 2, H: 1, W: 2 }) {
		return InitOtherView()
	}

	// Reset animation button
	if scene.AddBotton("Reset", { X: 4, Y: 2, H: 1, W: 2 }) {
		return InitExampleView()
	}
	
	ev.i++
	return ev
}
```

Tiene la simplicidad del modo inmediato pero veo difícil plantear conceptos que pasen el frame, como [[investigación/animation/Ease function|easing functions]] las cuales perduran por un cierto tiempo 

#### Conclusión
---
Lo que puedo concluir, es que para modo inmediato, en general se simplifica la creación, el uso y el agregarlo a la escena, esto representa una simplicidad el código. Por otro lado en el modo de retain, tiene la ventaja de mantener los objetos haciendo operaciones que duran varios frames de forma simple

```go
// Retain mode
func (ev *ExampleView) View(scene *s.Scene, yield FnYield) View {
    // Creation
    button := v.AddBotton({ Text: "hola", X: 0, Y: 0, H: 1, W: 2 })

    // Add to scene
    scene.Add(button)
    
    // Use
    if button.Check() {
        // ...
    }

    return nil
}

// Immediate mode
func (ev *ExampleView) View(scene *s.Scene) View {
    if scene.AddBotton({ Text: "hola", X: 0, Y: 0, H: 1, W: 2 }) {
        // ...
    }
    
    return ev
}
```

Por otro lado, la modularización de visualizaciones en immediate mode se simplifica ya que una función con acceso a la escena bastaría para mostrar modularizar lo que se quiere mostrar. En retain mode, se tiene dos opciones, donde se crea una función únicamente pasando los objetos ya generados para mostrar algo (pseudo immediate mode), donde lo único que hace la función es modificar los valores de los objetos, o como alternativa es crear más animaciones y por lo tanto necesitar el uso de funciones de ayuda para manejar multiples animaciones simultaneas

```go
// Retain mode
// No need to make a struct
func FirstAnimation(scene s.Scene, yield FnYield) View { / ... / }
func SecondAnimation(scene *s.Scene, yield FnYield) View { / ... / }

// Retain mode// No need to make a struct
func FirstAnimation(scene s.Scene, yield FnYield) View { / ... / }
func SecondAnimation(scene *s.Scene, yield FnYield) View { / ... / }

// Retain mode// No need to make a struct
func FirstAnimation(scene s.Scene, yield FnYield) View { / ... / }
func SecondAnimation(scene *s.Scene, yield FnYield) View { / ... / }

// Retain mode
// No need to make a struct
func FirstAnimation(scene *s.Scene, yield FnYield) View { /* ... */ }
func SecondAnimation(scene *s.Scene, yield FnYield) View { /* ... */ }

func (ev *ExampleView) View(scene *s.Scene, yield FnYield) View {
    firstBox := v.NewBox({ /* ... */ })
    secondBox := v.NewBox({ /* ... */ })
    scene.Add(firstBox, secondBox)
    
    // Only render other animation    
    v.Animate(yield,
        { Box: firstBox, Animation: FirstAnimation },
        { Box: secondBox, Animation: SecondAnimation },
    )
    
    // Render animations and this view
    

    return nil
}

func FirstAnimation(scene *s.Scene) { /* ... */ }
func SecondAnimation(scene *s.Scene) { /* ... */ }

// Immediate mode
func (ev *ExampleView) View(scene *s.Scene) View {
    FirstAnimation(scene)
    SecondAnimation(scene)
    
    return ev
}
```

Claramente el immediate mode gena en estos aspectos, por lo que no podemos simplemente escapar de sus ventajas que claramente superan las de retain mode. También cabe aclarar que las implementaciones pueden cambiar y por lo tanto el crear y el agregar podría ser mejor para retain mode, donde se podría simplificar a lo siguiente

```go
type Scene struct { /* ... */ }

func (s *Scene) Add[Obj Object](object Obj) Obj {
    // Add logic
    return object
}

// In the animation
func (ev *ExampleView) View(scene *s.Scene, yield FnYield) View {
    // Creation and addition to the scene
    botton := scene.Add(v.NewBotton({ Text: "hola", X: 0, Y: 0, H: 1, W: 2 }))
    
    // Use
    if button.Check() {
        // ...
    }

    return nil
}
```

La ventaja principal de retain mode, esta siendo la las animaciones más complejas ya que se tiene referencia a objetos sin tener que crearlos constantemente, es algo que tampoco se debería dejar de lado, ya que recordemos que la intención es poder crear los layouts y las animaciones de nuestra aplicación con esta herramienta



